# 快速排序


## 算法原型

快速排序也是基于**分治思想**实现的，所以我们先解决一个基本问题。

给定一个值K，将数组`arr`中的元素划分三个区域：`[元素值小于K的区域，元素值等于K的区域，元素值大于K的区域]`，并返回中间区域的下标范围。

上述问题将数据分为了三个部分，或者说三种颜色，也形象比喻为**荷兰国旗问题**。

### 划分思路

经典的解决思路是通过**双指针**解决。

定义三个变量：`l, r, i`。

`l`表示`[0,l]`为元素值小于`K`的区域，`l`的初始值为`-1`，表示元素值小于`K`的区域。

`r`表示`[r,arr.length - 1]`为元素值大于`K`的区域，`r`的初始值为`arr.length`，表示元素值大于`K`的区域。

`i`表示当前遍历到的元素下标，通过下标`i`遍历数组`arr`，并作以下判断判断。

- 若当前遍历元素的`i`与大于区域交错，即`i>=r`，表示区域划分结束，遍历结束，即循环条件为`i < r`。
- 若当前遍历到的下标元素`i`，元素值`arr[i] < K`，则将`arr[i]`交换至元素值小于K的区域，先扩大元素值小于K的区域，即`++l`，然后将当前下标`i`与`l`进行交换，即：`swap(arr, ++l, i)`，同时`[0,i]`的元素我们已经遍历过了，所以`i++`。
- 若当前遍历到的下标元素`i`，元素值`arr[i] > K`，则将`arr[i]`交换至元素值大于K的区域，先扩大元素值大于K的区域，即`--r`，然后将当前下标`i`与`r`进行交换，即：`swap(arr, --r, i)`，由于**交换后的arr[i]我们没有判断，所以i不可以加1**。
- 若当前遍历到的下标元素`i`，元素值`arr[i] == K`，直接`i++`跳过即可，因为上述两个条件可以划分出小于的区域和大于的区域，中间的区域则是等于的区域。

### 代码

```java
public class QuickBase {

    public void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public int[] base(int[] arr, int K) {
        // l 表示 [0,l]为元素值小于K的区域
        // r 表示 [r,arr.length - 1]为元素值大于K的区域
        // i 表示 当前遍历的元素下标
        int l = -1, r = arr.length, i = 0;
        while(i < r) { // 当前遍历的元素下标碰到了元素值大于K的区域，表示区域划分结束
            if(arr[i] < K) {
                swap(arr, ++l, i);
                i++; // [0,i]的元素我们已经遍历过了，所以`i++`
            }else if(arr[i] > K) {
                swap(arr, --r, i);
                // 交换后的arr[i]我们没有判断，所以i不可以加1
            }else {
                i++; // 元素值arr[i] == K，直接i++跳过即可
            }
        }
        // 区域划分结束
        // [0,l]为元素值小于K的区域
        // [r,arr.length - 1]为元素值大于K的区域
        // [l+1,r-1]为元素值等于K的区域，若区域交错则证明数组arr中没有等于K的元素值
        return new int[] {
                l + 1,
                r - 1
        };
    }

}
```






