# 快速排序

## 算法原型

快速排序也是基于**分治思想**实现的，所以我们先解决一个基本问题。

给定一个值K，将数组`arr`中的元素划分三个区域：`[元素值小于K的区域，元素值等于K的区域，元素值大于K的区域]`，并返回中间区域的下标范围。

上述问题将数据分为了三个部分，或者说三种颜色，也形象比喻为**荷兰国旗问题**。

### 划分思路

经典的解决思路是通过**双指针**解决。

定义三个变量：`l, r, i`。

`l`表示`[0,l]`为元素值小于`K`的区域，`l`的初始值为`-1`，表示元素值小于`K`的区域。

`r`表示`[r,arr.length - 1]`为元素值大于`K`的区域，`r`的初始值为`arr.length`，表示元素值大于`K`的区域。

`i`表示当前遍历到的元素下标，通过下标`i`遍历数组`arr`，并作以下判断。

- 若当前遍历下标`i`与大于区域交错，即`i>=r`，表示区域划分结束，遍历结束，即循环条件为`i<r`。
- 若当前遍历到的下标元素`i`，元素值`arr[i] < K`，则将`arr[i]`交换至元素值小于K的区域，先扩大元素值小于K的区域，即`++l`，然后将当前下标`i`与`l`进行交换，即：`swap(arr, ++l, i)`，同时`[0,i]`的元素我们已经遍历过了，所以`i++`。
- 若当前遍历到的下标元素`i`，元素值`arr[i] > K`，则将`arr[i]`交换至元素值大于K的区域，先扩大元素值大于K的区域，即`--r`，然后将当前下标`i`与`r`进行交换，即：`swap(arr, --r, i)`，由于**交换后的arr[i]我们没有判断，所以i不可以加1**。
- 若当前遍历到的下标元素`i`，元素值`arr[i] == K`，直接`i++`跳过即可，因为上述两个条件可以划分出小于的区域和大于的区域，中间的区域则是等于的区域。

### 代码

```java
public class QuickBase {

    public void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public int[] base(int[] arr, int K) {
        // l 表示 [0,l]为元素值小于K的区域
        // r 表示 [r,arr.length - 1]为元素值大于K的区域
        // i 表示 当前遍历的元素下标
        int l = -1, r = arr.length, i = 0;
        while(i < r) { // 当前遍历的元素下标碰到了元素值大于K的区域，表示区域划分结束
            if(arr[i] < K) {
                swap(arr, ++l, i);
                i++; // [0,i]的元素我们已经遍历过了，所以`i++`
            }else if(arr[i] > K) {
                swap(arr, --r, i);
                // 交换后的arr[i]我们没有判断，所以i不可以加1
            }else {
                i++; // 元素值arr[i] == K，直接i++跳过即可
            }
        }
        // 区域划分结束
        // [0,l]为元素值小于K的区域
        // [r,arr.length - 1]为元素值大于K的区域
        // [l+1,r-1]为元素值等于K的区域，若区域交错则证明数组arr中没有等于K的元素值
        return new int[] {
                l + 1,
                r - 1
        };
    }

}
```

## 实现思路

快速排序与归并排序类似，不同的是，先将一个规模较大的数组`[i,j]`通过算法原型划分为`[元素值小于K的区域，元素值等于K的区域，元素值大于K的区域]`三个区域后，目前能确定`元素值等于K的区域`是排序后的正确位置，后续过程不会发生改变，递归去划分`元素值小于K的区域`以及递归去划分`元素值大于K的区域`。

但对于每个区域的划分来说，必须有一个值`K`，作为基准值，来辅助划分，一般会在数组中的选一个元素值作为基准值。

需要注意的是，这个值若是最大值或是最小值都会产生无效的区域划分，所以最好在数组中随机选一个元素值，降低平均选中最大/小值的概率。

接下来模拟快排过程，模拟数组`A`的快排过程。

- `数组A`通过**算法原型**划分为为三个较小的数组`A1、B1、C1`，其中`B1`的位置已经确定，解决`A1、C1`的问题。(1)
    - `数组A1`通过**算法原型**划分为为三个较小的数组`A2、B2、C2`，其中`B2`的位置已经确定，解决`A2、C2`的问题。(2)
        - `数组A2`通过**算法原型**划分为为三个较小的数组`A3、B3、C3`，其中`B3`的位置已经确定，解决`A3、C3`的问题。(3)
        - `数组C2`通过**算法原型**划分为为三个较小的数组`A3、B3、C3`，其中`B3`的位置已经确定，解决`A3、C3`的问题。(4)
    - `数组C1`通过**算法原型**划分为为三个较小的数组`A2、B2、C2`，其中`B2`的位置已经确定，解决`A2、C2`的问题。(5)
        - `数组A2`通过**算法原型**划分为为三个较小的数组`A3、B3、C3`，其中`B3`的位置已经确定，解决`A3、C3`的问题。(6)
        - `数组C2`通过**算法原型**划分为为三个较小的数组`A3、B3、C3`，其中`B3`的位置已经确定，解决`A3、C3`的问题。(7)

在这里，我们假定`A3、C3`是规模最小的划分，是只有`1`个元素的子数组，不需要进行区域划分过程。

以上过程中，每次执行都会经过**算法原型**来划分区域，不断的减小规模，将`小于某个值的元素放左边，等于某个值的元素放中间，大于某个值的元素放右边`，以`中间区域的元素`作为辅助，完成局部的相对次序排序，从而完成整个数组的排序。

## 动画(一图胜千言)

> 默认数据是随机产生的，可自行输入数据或再次点击随机生成，记得点击确认。
>
> 动画模式有单步调试/自动播放两种模式。
>
> 单步调试：需不停的点击"下一步"完成执行流程。

<br>
<quick-sort />

## 代码

```java
public class QuickSort {

    public void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public void sort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    // 改写QuickBase，以支持[start,end]区间的荷兰国旗问题
    public int[] partition(int[] arr, int start, int end, int K) {
        // l 表示 [start,l]为元素值小于K的区域
        // r 表示 [r,end]为元素值大于K的区域
        // i 表示 当前遍历的元素下标
        int l = start - 1, r = end + 1, i = start;
        while(i < r) { // 当前遍历的元素下标碰到了元素值大于K的区域，表示区域划分结束
            if(arr[i] < K) {
                swap(arr, ++l, i);
                i++; // [0,i]的元素我们已经遍历过了，所以`i++`
            }else if(arr[i] > K) {
                swap(arr, --r, i);
                // 交换后的arr[i]我们没有判断，所以i不可以加1
            }else {
                i++; // 元素值arr[i] == K，直接i++跳过即可
            }
        }
        // 区域划分结束
        // [start,l]为元素值小于K的区域
        // [r,end]为元素值大于K的区域
        // [l+1,r-1]为元素值等于K的区域，若区域交错则证明数组arr中没有等于K的元素值
        return new int[] {
                l + 1,
                r - 1
        };
    }

    private void quickSort(int[] arr, int i, int j) {
        if(i >= j) return; // 元素个数小于等于1，不需要划分直接return
        // 对于每个区域的划分来说，必须有一个值`K`，作为基准值，来辅助划分，一般会在数组中的选一个元素值作为基准值。
        // 需要注意的是，这个值若是最大值或是最小值都会产生无效的区域划分，所以最好在数组中随机选一个元素值，降低平均选中最大/小值的概率。
        int randIndex = i + (int)(Math.random() * (j - i + 1));
        int K = arr[randIndex];

        // 确定等于K的区域
        int[] range = partition(arr, i, j, K);

        // 小于K的区域递归执行
        quickSort(arr, i, range[0] - 1);

        // 大于K的区域递归执行
        quickSort(arr, range[1] + 1, j);
    }

}

```