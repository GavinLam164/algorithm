# 归并排序 *

## 算法原型

在学习归并排序之前，我们先解决一个基本问题。

如何高效的合并两个长度不相等的**有序数组**，合并后的数组也要保持有序。
### 合并思路

已知数组A、数组B为有序数组，若A数组长度为`N`，B数组长度为`M`，则合并后的数组ret长度为`N+M`。

设i为数组A的下标，j为数组B的下标，z为数组ret的下标。

我们依次比较`A[i]`与`B[j]`的元素值。

- 若`A[i]`的元素值比`B[j]`的元素值要小，证明`A[i]`在合并后的数组ret中顺序靠前，则将`A[i]`放到ret中，同时由于`A[i]`已经被放到ret中，则`z++，i++`，简化代码：`ret[z++] = A[i++]`。
- 若`A[i]`的元素值比`B[j]`的元素值要大，证明`A[i]`在合并后的数组ret中顺序靠后，则将`B[j]`放到ret中，同时由于`B[j]`已经被放到ret中，则`z++，j++`，简化代码：`ret[z++] = B[j++]`。

简短实现：
```java
while(i < A.length && j < B.length) {
	ret[z++] = A[i] < B[j] ? A[i++]: B[j++];
}
```

在以上过程中，有可能A先遍历完或B先遍历完，所以需要单独处理没遍历完的情况。

```java
while(i < A.length) {
	ret[z++] = A[i++];
}

while(j < B.length) {
	ret[z++] = B[j++];
}
```

### 完整代码
```java
public class MergeBase {
    public int[] base(int[] A, int[] B) {
        int[] ret = new int[A.length + B.length];
        int i = 0, j = 0, z = 0;

        while(i < A.length && j < B.length) {
            ret[z++] = A[i] < B[j] ? A[i++]: B[j++];
        }

        while(i < A.length) {
            ret[z++] = A[i++];
        }

        while(j < B.length) {
            ret[z++] = B[j++];
        }
        return ret;
    }
}
```

## 实现思路

归并排序基于**分治思想**实现，通过将一个大的数组`arr`，从中间拆分为两个较小的数组`A、B`，在**假设数组A、数组B已经有序的情况下**，通过上述的**算法原型**进行合并数组，再将合并后的有序数组复制到原数组`arr`中，完成排序过程。

那么如何让`数组A、数组B`变的有序呢，我们先从让`数组A`变有序开始分析。

- `数组A`也可以从中间拆分为两个较小的数组`A1、B1`。(7)
    - `数组A1`也可以从中间拆分为两个较小的数组`A2、B2`。(3)
        - `数组A2`也可以从中间拆分为两个较小的数组`A3、B3`。(1)
        - `数组B2`也可以从中间拆分为两个较小的数组`A3、B3`。(2)
    - `数组B1`也可以从中间拆分为两个较小的数组`A2、B2`。(6)
        - `数组A2`也可以从中间拆分为两个较小的数组`A3、B3`。(4)
        - `数组B2`也可以从中间拆分为两个较小的数组`A3、B3`。(5)

这里我们采用自底向上进行分析。

(1) 假设，将数组`A2`也可以从中间拆分为两个较小的数组`A3、B3`，`A3、B3`是两个元素个数为`1`的数组，此时进行**算法原型**进行合并数组的过程，将`A3、B3`进行合并，再复制回`A2`，即可使得`A2`成为有序数组。

(2) 在解决完数组`A2`有序之后，将`数组B2`也可以从中间拆分为两个较小的数组`A3、B3`，进行**算法原型**进行合并数组的过程，将`A3、B3`进行合并，再复制回`B2`，即可使得`B2`成为有序数组。

(3) 当`A2、B2`都成为有序数组后，进行**算法原型**进行合并数组的过程，将`A2、B2`进行合并，再复制回`A1`，即可使得`A1`成为有序数组。

(4,5,6) 同理，`B1`也进行相同的过程。

(7) 此时`A1、B1`都成为了有序数组，进行**算法原型**进行合并数组的过程后，再复制回`A`，即可使得`A`成为有序数组。

同理，`B`也进行相同过程，`A、B`合并后复制到数组`arr`中，使得`arr`成为有序数组。

在上述过程中，不断的将输入数组拆分为两个规模更小的子数组，在解决两个规模更小的子数组的问题之后，再将这两个有序子数组进行合并，体现了**分治思想**。

由于执行过程高度相似，可通过递归实现，读者初次接触可能会比较难理解，可结合代码、动画理解上述过程。

需要注意的是，每次递归总是将规模较大的问题拆解为两个规模较小的子问题进行递归，所以第一次执行合并时实际上是从规模最小的范围开始的。

## 动画(一图胜千言)

> 默认数据是随机产生的，可自行输入数据或再次点击随机生成，记得点击确认。
>
> 动画模式有单步调试/自动播放两种模式。
>
> 单步调试：需不停的点击"下一步"完成执行流程。

<br>
<merge-sort />

## 代码

```java
public class MergeSort {

    public void sort(int[] arr) {
        mergeSort(arr, 0, arr.length - 1);
    }

    private void mergeSort(int[] arr, int i, int j) {
        if(i >= j) return;
        int mid = i + (j - i) / 2;
        // 解决[i, mid]的子数组问题
        mergeSort(arr, i, mid);
        // 解决[mid+1, j]的子数组问题
        mergeSort(arr, mid + 1, j);
        // 合并两个有序数组
        merge(arr, i, mid, j);
    }

    // 改写算法原型MergeBase
    private void merge(int[] arr, int i, int m, int j) {
	    // 区间[i,j]的元素个数为(j - i + 1)
        int[] ret = new int[j - i + 1];
        int z = 0;
	    // 通过数组下标m将arr划分为两个子数组，l为子数组A下标，r为子数组B下标
        int l = i, r = m + 1;

        while(l <= m && r <= j) {
            ret[z++] = arr[l] < arr[r] ? arr[l++]: arr[r++];
        }

        while(l <= m) {
            ret[z++] = arr[l++];
        }

        while(r <= j) {
            ret[z++] = arr[r++];
        }

        // 将ret复制回原数组
        for(z = 0; z < ret.length; z++) {
            arr[i+z] = ret[z];
        }
    }

}
```







